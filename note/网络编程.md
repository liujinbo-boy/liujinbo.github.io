### 一、通信模型

​	Linux中的网络通信有完善的通信模型，如：一对一的通信，一对多的通信模型等。


其中，典型的一对一的通信模型如下：

服务端：

​	1、创建通信节点(通信设备)，类似电话通信中的那个电话，使用函数**socket**
​	2、绑定(准备通信地址，相当于买一个电话卡)，使用函数**band**

​	3、监听，使用函数**listen**

​	4、接收连接，使用函数**accept**
​	5、发生/接收数据，使用函数 **read/write** 或者 **send/recv**

​	6、断开连接 **close**

客户端：
	1、创建通信节点(通信设备)，类似电话通信中的那个电话，使用函数**socket**
	2、连接(知道对方的通信地址)，使用函数 **connect**

​	3、发送/接收数据，使用函数 **read/write** 或者 **send/recv**
​	4、断开连接 **close**



### 二、网络编程相关API

#### 2.1 socket

```c
SYNOPSIS
       #include <sys/types.h>          /* See NOTES */
       #include <sys/socket.h>

    功能: 创建一个通信节点(通信设备)
int socket(int domain, int type, int protocol);
	domain: 协议域  有多种，多数情况下用
		AF_UNIX, AF_LOCAL   本地协议              unix(7)
        AF_INET             IPV4协议             ip(7)
        AF_INET6            IPv6协议              ipv6(7)
		.......
	type: 套接字类型，常用如下：
		SOCK_STREAM   流式套接字
			特点: 有序，可靠，双向，基于连接的字节流
        SOCK_DGRAM   数据报(包)套接字   
			特点: 无连接，不可靠，有最大长度限制，传输速度快
		.....
	protocol: 具体的协议
		通常情况下，每种type的套接字，只有一种协议实现了相关要求
		如:
			SOCK_STREAM  具体的实现协议叫TCP(transmit control protocol)传输控制协议
			SOCK_DGRAM   具体的实现协议叫UDP(user datagram protocol)用户数据报(包)协议(用户数据协议)
		所以如果使用第一种具体的协议，写0即可

返回值:
	成功返回一个套接字描述符，后续的网络相关接口，都需要使用这个描述符来操作这个通信的套接字以实现通信的功能
	失败返回-1，同时errno被设置

示例:
	int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if(sockfd == -1)
    {
        perror("socket error");
        exit(1);
    }
```

#### 2.2 bind

```c
NAME
       bind - bind a name to a socket

SYNOPSIS
       #include <sys/types.h>          /* See NOTES */
       #include <sys/socket.h>
	功能：绑定一个通知地址到指定的套接字
int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
	sockfd: 套接字描述符，即socket成功的返回值
	addr: 是一个struct sockaddr类型的指针，表示通信地址
	addrlen: 通信地址的长度，单位是字节
返回值:
	成功返回0
	失败返回-1，同时errno被设置

说明：
	struct sockaddr是通用的地址描述结构，所有的通信协议地址最后都必须转化为此类型
	struct sockaddr {
         sa_family_t sa_family;
         char        sa_data[14];
    }
	IPV4这种协议的通信地址,如下:
	struct sockaddr_in {
        sa_family_t    sin_family; /* 协议族: AF_INET */
        in_port_t      sin_port;   /* 网络字节序的端口 */
        struct in_addr sin_addr;   /* ip地址 */
        char           sin_zero[8];  // 填充字段（通常置零）
    };

    /* Internet address. */
    struct in_addr {
        uint32_t       s_addr;     /* 网络字节格式的整数形式的IP地址 */
    };


示例:
    struct sockaddr_in addr;
    addr.sin_family = AF_INET; //协议族
    addr.sin_port = htons(10086); //端口号
    addr.sin_addr.s_addr = inet_addr("172.100.1.41"); //必须是本机的有效IP地址
    int ret = bind(sockfd, (struct sockaddr*)&addr, sizeof(addr));
    if(ret == -1)
    {
        perror("bind error");
        exit(1);
    }
```

######  htons

```
功能: 本地端口号转化为网络字节格式的端口号
SYNOPSIS
       #include <arpa/inet.h>
uint16_t htons(uint16_t hostshort);
	hostshort：需要进行转化的端口号
```

###### inet_addr ，inet_ntoa

```
SYNOPSIS
       #include <sys/socket.h>
       #include <netinet/in.h>
       #include <arpa/inet.h>

      功能: 把点分十进制形式的IP转化为网络字节序形式的IP
in_addr_t inet_addr(const char *cp);

	  功能: 把网络字节序形式的IP转为点分十进制形式的IP
char *inet_ntoa(struct in_addr in);
```

函数原型

###### inet_aton

inet_aton函数的原型定义在`<arpa/inet.h>`头文件中，具体原型如下：

```c
#include <arpa/inet.h>

int inet_aton(const char *cp, struct in_addr *inp);
```

2. 参数说明

- **cp**：指向一个以null结尾的字符串，该字符串表示一个IPv4地址，格式为点分十进制（如"192.168.1.1"）。
- **inp**：指向一个`struct in_addr`结构体的指针，该结构体用于存储转换后的网络字节序的IP地址。`struct in_addr`结构体通常包含一个名为`s_addr`的成员，该成员是一个无符号32位整数，用于存储网络字节序的IP地址。

3. 返回值

- 如果转换成功，inet_aton函数返回非零值（通常是1）。
- 如果转换失败（例如，因为输入的字符串不是一个有效的IPv4地址），则函数返回零

#### 

#### 2.3 listen

```c
SYNOPSIS
       #include <sys/types.h>          /* See NOTES */
       #include <sys/socket.h>
	功能: 监听套接字是否有连接请求
int listen(int sockfd, int backlog);
	sockfd: 套接字描述符
	backlog:这个参数定义了等待接受连接的最大队列长度。当一个连接请求到达时，如果服务器没有调用 accept 来处理这个连接，那么这个连接请求会被放入队列中等待。这个参数指定了队列的最大长度。注意，这个参数的实际行为可能因不同的系统而异，并且实际队列长度可能会受到系统资源的限制。
        
        
返回值:
	成功返回0
	失败返回-1，同时errno被设置
```

#### 2.4 accept

```c
NAME
       accept — accept a new connection on a socket

SYNOPSIS
       #include <sys/socket.h>
	
    功能: 从监听队列中获取第一个待处理的连接
int accept(int socket, struct sockaddr *restrict address,
           socklen_t *restrict address_len);
	socket: 套接字描述符
	address: struct sockaddr类型的指针，用来保存连接过来的客户端的地址信息
	address_len: socklen_t 类型的指针，指向的是地址结构的长度，调用时必须初始化
返回值：
	成功返回一个新的连接套接字，该套接字用来与客户端进行通信
	失败返回-1，同时errno被设置

示例:
	struct sockaddr_in client_addr; //保存客户端的地址信息
    socklen_t len = sizeof(client_addr);
    int confd = accept(sockfd, (struct sockaddr*)&client_addr, &len);
    if(confd == -1)
    {
        perror("accpt errror");
    }
    printf("new client : %s\n", inet_ntoa(client_addr.sin_addr));	
```

#### 2.5 connect

```c
NAME
       connect - initiate a connection on a socket

SYNOPSIS
       #include <sys/types.h>          /* See NOTES */
       #include <sys/socket.h>

    功能: 用于连接服务器
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
	sockfd: 套接字描述符，用于连接服务端的套接字描述符
	addr: 表示需要连接的服务端的地址信息
	addrlen: 表示地址结构的长度
返回值:
	成功返回0
	失败返回-1，同时errno被设置

说明：
	只有服务端在调用了accept之后，才认为连接成功了，此时可以与服务端进行通信
```



#### 2.6 recv（tcp）

```
#include <sys/socket.h>  
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
```

参数

- `sockfd`：是一个套接字描述符，它标识了一个打开的网络连接。
- `buf`：是指向接收数据缓冲区的指针，`recv` 函数会将接收到的数据复制到这个缓冲区中。
- `len`：指定了缓冲区的长度，即 `recv` 函数最多可以接收多少字节的数据。
- `flags`：指定了额外的选项，0表示不设置任何选项。
  1. ‌**MSG_OOB**‌ == 0x01
     用于接收‌**带外数据**‌（Out-of-Band Data），对应TCP协议中URG标志位标记的紧急数据。该模式允许优先处理特定数据段，常用于心跳检测或紧急控制指令‌
  2. ‌**MSG_PEEK**‌
     从接收缓冲区中‌**查看数据但不移除数据**‌。启用后，下次调用recv仍会读取相同内容，适用于多进程/多线程需共享接收数据的场景‌
  3. ‌**MSG_WAITALL**‌
     强制要求‌**接收指定长度的完整数据后函数才返回**‌。例如若请求100字节，recv会持续阻塞直到缓冲区有足够数据，避免多次分批接收的复杂性‌

返回值

- 成功时，`recv` 返回实际接收到的字节数。这个值可以是 0 到 `len` 之间的任何值，包括 0（这通常表示连接已正常关闭，但也可以通过设置套接字选项来禁用这种行为）。

- 如果连接被对方关闭或出错，`recv` 会返回 -1，并设置 `errno` 以指示错误

  `-1` 表示发生了某种错误，这可能是由于多种原因，包括但不限于客户端断开连接。
  
   ` 0` 则明确表示连接已经正常关闭，没有更多的数据可读。在编写网络程序时，应该根据这些返回值来适当地处理错误和连接关闭的情况。

#### 2.7 send（tcp）

```
int send(int s, const void *msg, size_t len, int flags);
```

#### 2.8 getaddrinfo() 

```


```

getaddrinfo() 是将域名和端口名转为地址，而 getnameinfo() 是将地址转为域名和端口名。

#### 2.9 getnameinfo() 

```


```



### 三 、网络通信数据包

1、通信双方的字节序可能不同，如:  客户端是小端模式，而服务端是大端模式

2、通信双方的数据类型长度可能不一样，如：客户端是32位，而服务端是64位

3、通信双方的发生和接收的次数可能不一样，如: 客户端连续发生两次数据，而服务端有可能一次就把客户端的两次的数据读走了。
........

```c
例如：
	client: 
		char* buf[100] = {"hello", "world"};
		write(confd, buf[0], strlen(buf[0]));
	    write(confd, buf[1], strlen(buf[1]));
	server:
		char str[100] = {0};
		read(confd, str, sizeof(str));
```

假设客户端给服务端发送两个数据包D1和D2，由于服务端一次读取的字节数不确定，可能会存在以下情况：

1、服务端一次性就读取到了两个数据包，即D1和D2紧挨在一起(粘包)
2、服务端分两次读取到两个独立的数据包
3、服务端两次读到两个包，第一次读取到D1的部分内容，第二次读取到D1的剩下的内容和D2全部的内容(半包)
4、服务端两次读到两个包，第一次读取到D1的全部内容和D2的部分内容，第二次读取到D2的剩下的内容



以上问题，一般通过应用程序自己定义数据格式来解决，即应用程序协议，常用方法:

1、消息定长   如: 每个数据包固定大小为100个字节，如果待发送的数据不足100个字节，填充某种字节(如0)以凑够100个字节



2、把带发送的数据转化为字符串，然后在数据包的（头部和）尾部添加特定的分界符号进行消息的切割，如： http协议以\n为数据包的分界符



3、将消息分为两部分，即消息头和消息体，消息头中可以包括消息的属性信息: 长度，类型..... 消息体就是真正要发送的数据，通常消息头的大小是固定的。

```c
/**
 * @brief 对read函数再次封装，读取指定字节的数据
 * 
 * @param confd 连接套接字
 * @param buf 指向保存数据的空间
 * @param len 指定读取的字节数
 * @return int 
 *      1、能读取到len个字节的数据，则返回len
 *      2、无法读取到len个字节的数据，则返回实际读取到的字节数
 *      3、读取失败，返回-1
 */
int readn(int confd, char* buf, int len)
{
    int readed_bytes = 0; //记录已经读取到的字节数

    while(1)
    {
        int ret = read(confd, buf+readed_bytes, len-readed_bytes);
        if(ret == -1)
            return -1;
        
        if(ret == 0) //连接已经断开
            return readed_bytes;

        //记录成功读取到多少字节的数据
        readed_bytes += ret;

        //已经读取到指定字节的数据
        if(readed_bytes == len)
            return readed_bytes;
    }
}
/*
参数 data:数据包(格式包由用户定义--结构体)
*/
bool RecvShujubao(int sockfd,void * data,int len)
{
	unsigned char * recvdata = (unsigned char *)data;
	int recvlen = 0;
	while(recvlen != len)
	{
		int r = recv(sockfd,recvdata + recvlen,len - recvlen,0);
		if(-1 == r)
		{
			perror("RecvShujubao error ");
			return false;
		}
		else if(0 == r)
		{
			printf("对方断开了，接不到了\n");
			return false;
		}
		recvlen += r;
	}
	
	if(Panduanbaoshibushiwanzhengde(data))
		return true;
	
	return false;
}
```



```c
//对文件名的数据包进行分装
char buf[1024] = {0};
char* filename = "./基于TCP协议的通信流程.jpg"; //消息体
int type = FILENAME; //消息类型
int len = strlen(filename); //消息体的长度
sprintf(buf, "%4d%4d%s", len, type, filename);
printf("buf : %s\n", buf);

注意:
	文件数据可以使用sprintf的方式进行合并，但是部分二进制数据文件则需要使用memcpy
```



### 四、套接字选项

#### 4.1 setsockopt

问题:
		当客户端与服务端正常通信时，如果服务端主动断开连接，再次重启服务端，此时系统会提示：
		bind error: Address already in use

解决办法:
		1、Linux中，等一分钟，服务端可以重新使用
		2、修改套接字选项，允许地址立即重用

```c
NAME
       getsockopt, setsockopt - get and set options on sockets

SYNOPSIS
       #include <sys/types.h>          /* See NOTES */
       #include <sys/socket.h>

  功能: 用来设置套接字选项
int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen);
	sockfd: 待修改的套接字描述符
	level: 待修改的套接字所在的层次名称
	optname: 待修改的套接字选项名
	optval: 把套接字选项的值修改为optval指向的值
	optlen: optlen指向值的长度
返回值:
	成功返回0
	失败返回-1，同时errno被设置

说明:
	对于地址重用这个套接字选项：
		层次名称: SOL_SOCKET
		套接字选项名称: SO_REUSEADDR
		它的值的类型是int, 默认就是0，表示禁止此功能
		如果修改为非0， 如1， 就表示开启此功能

注意:
	对套接字选项的修改需要在绑定IP地址之前
```



### 五、IO复用服务器

指的就是一个进程"同时"处理多个文件描述符的IO操作


在Linux中，以下函数都能实现IO复用功能

​		select 
​		poll
​		epoll

#### 6.1 select

```c
SYNOPSIS
       /* According to POSIX.1-2001, POSIX.1-2008 */
       #include <sys/select.h>

       /* According to earlier standards */
       #include <sys/time.h>
       #include <sys/types.h>
       #include <unistd.h>
	功能: 用于监控多个文件描述符，直到一个或多个文件描述符"就绪"(指调用read、write不会阻塞)
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
	nfds: 表示监测的范围，即文件描述符集合中的描述符最大值加1
	readfds: 文件描述符集合，select会检测该文件描述符是否可以进行无阻塞的读
	writefds: 文件描述符集合，select会检测该文件描述符是否可以进行无阻塞的写
    exceptfds: 文件描述符集合，select会检测该文件描述符是否发生异常
	timeout: 时间结构，表示超时时间，有一下三种写法
        NULL		表示一直阻塞到有文件描述符就绪
		timeout结构体成员大于0   表示阻塞指定的时间
		timeout结构体成员等于0   表示不阻塞
		struct timeval {
               long    tv_sec;         /* 秒 */
               long    tv_usec;        /* 微秒 */
           };
返回值:
	如果返回-1，表示失败返回，同时errno被设置
	如果返回0，表示超时返回
	如果返回值大于0，返回准备就绪的文件描述符的数量

注意:
	 对于参数中的三个文件描述符集合，如果不需要，可以置为NULL  
        
fd_set是内核同的一种数据结构，其本质就是一个bit位数组，默认大小为1024
void FD_CLR(int fd, fd_set *set);		//移除set集合中的fd描述符
int  FD_ISSET(int fd, fd_set *set);     //判断fd描述符是不是在set集合中
void FD_SET(int fd, fd_set *set);		//把描述符fd加入到集合set中
void FD_ZERO(fd_set *set);              //把set集合全部置零

说明:
	1、当select函数返回后，如果不是超时返回
		此时timeout参数不再生效，即如果再次调用select，需要重新设置超时时间
	2、当select函数返回后，如果是超时返回
		此时timeout参数不再生效，同时会自动清空集合中的所有描述符，即如果需要再次调用select，需要重新把文件描述符添加到监控集合中
	3、当select返回后，如果不是超时返回或者出错返回
		此时，监控结合中只剩下"就绪"的文件描述符，那些没有"就绪"的文件描述符就被清理掉了，即如果需要再次调用select,需要重新把没有"就绪"的文件描述符添加到监控集合中
```

select函数的基本使用步骤：

>1、创建一个描述符集合，清空
>
>2、把需要监控的描述符加入到集合中
>
>3、设置监控范围，集合中最大描述符加一
>
>4、设置超时时间
>5、调用select函数
>6、根据select的返回值，进行相应的处理
>		如果是出错返回，查看错误原因，并退出
>		如果是超时了，继续监控
>		如果有文件描述符就绪了，则找到就绪的描述符，进行对应的处理



#### 6.2 poll

```c
poll()  performs a similar task to select(2): it waits for one of a set of file descriptors to become ready to perform I/O.
    
select()  can  monitor  only  file  descriptors  numbers  that are less than FD_SETSIZE;poll(2) does not have this limitation.

说明: 
	poll实现的功能与select相似，它们的区别就是select的监控的描述符是有上限的(FD_SETSIZE),poll没有监控上限
	

NAME
       poll, ppoll - wait for some event on a file descriptor

SYNOPSIS
       #include <poll.h>

      功能: 监控文件描述符是否就绪
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
	fds: struct pollfd类型的指针，一般是监控结构体数组的首地址
	nfds: 表示第一个参数struct pollfd数组中的元素个数(需要监控的描述符的数量)
	timeout: 超时时间  单位ms
返回值:
	>0   表示就绪的文件描述符的数量
	=0	 表示超时
	=-1  表示出错，errno被设置

监控结构体类型:
struct pollfd {
    int   fd;         /* 指定要监控的文件描述符 */
    short events;     /* 监控的事件 */
    			POLLIN	可读事件
                POLLOUT 可写事件
                POLLERR	错误事件
				......
				如果需要监控多个事件
				则：POLLIN | POLLOUT
    
    short revents;    /* 已经就绪的事件 */
    			如: 读操作是否已经就绪
				if(revent & POLLIN)
					可读
};

说明:
	监听一个文件描述符，就需要一个struct pollfd的结构体
	监听多个文件描述符，就需要多个struct pollfd的结构体
```



#### 6.4 epoll

IO多路复用机制中select和poll能够监控多个文件描述符，以查看那个文件描述符就绪了

在这两个系统调用里面，我们传递一个待监控的文件描述符集合给内核，之后内核返回一个修改过的集合，以表示那些文件描述符处于"就绪"状态



在每一次调用都需要传递完整的文件描述符集合，并在调用返回值后还要检查它们
当需要监控大量文件描述符时，select和poll的性能就会变差



Linux的特有的epoll机制，能够在**内核中“记住”进程正在监控的文件描述符集合**(select和poll需要反复告诉内核哪些文件描述符需要监控)，所以在监控大量文件描述符的时候，epoll的新年比较高效

```
The  epoll  API performs a similar task to poll(2): monitoring multiple file descriptors to see if I/O is possible on any of them. 监控大量的文件描述符，看它们中有哪些文件描述符就绪
```


由三个系统调用组成，基本工作流程如下:

>1、创建一个epoll实例(epoll_create)
>
>2、把需要监控的文件描述符加入到epoll实例中(epoll_ctrl)
>
>3、等待IO事件发生，当有IO事件发生的时候，**内核会保存准备就绪的描述符的信息**(epoll_wait)



##### 6.4.1 epoll_create

```c
NAME
       epoll_create, epoll_create1 - open an epoll file descriptor

SYNOPSIS
       #include <sys/epoll.h>
	功能: 创建一个epoll实例(开辟一块空间)
int epoll_create(int size);
	size: 即epoll实例的大小，从Linux2.6.8之后，系统会忽略这个参数，但是要求参数必须大于0
返回值:
	成功返回epoll实例的文件描述符，可以通过它来操作epoll实例
	失败返回-1，同时errno被设置
```

##### 6.4.2 epoll_ctl

```c
NAME
       epoll_ctl - control interface for an epoll file descriptor

SYNOPSIS
       #include <sys/epoll.h>
	功能: 用于控制epoll实例
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
	epfd: epoll实例的文件描述符，即epoll_create的返回值
	op: 操作
	   EPOLL_CTL_ADD	添加
       EPOLL_CTL_MOD    修改
       EPOLL_CTL_DEL    删除
	fd: 需要进行操作(添加，修改，删除)文件描述符
	event: 用于表示需要监控的事件
        typedef union epoll_data {
            void        *ptr;
            int          fd;
            uint32_t     u32;
            uint64_t     u64;
    	} epoll_data_t;

        struct epoll_event {
            uint32_t     events;      /* Epoll事件 */
            epoll_data_t data;        /* data是一个共用体，我们只使用它里面的fd */
        };      
监控的事件:
	EPOLLIN
              The associated file is available for read(2) operations.
    EPOLLOUT
              The associated file is available for write(2) operations.

返回值:
	成功返回0
	失败返回-1，同时errno被设置
```

##### 6.4.3 epoll_wait

```c
NAME
       epoll_wait, epoll_pwait - wait for an I/O event on an epoll file descriptor

SYNOPSIS
       #include <sys/epoll.h>
	功能: 等待epoll实例中的文件描述符就绪
int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);
	epfd: epoll实例的文件描述符
	events: 用来保存就绪的文件描述符的信息，需要用户提前定义
	maxevents: 表示events指向的空间可以存放多少事件结构(元素个数)
	 timeout: 超时时间，单位是ms
		>0   表示将会阻塞指定的时间
		=0   表示不阻塞
		=-1  表示一直阻塞，直到有事件发生

返回值:
	成功返回就绪的文件描述符的数量
	超时返回0
	失败返回-1，同时errno被设置

说明：
	IO复用的事件模式，有两种模式
	水平触发：
		select/poll都默认使用的是水平触发
		即只要有数据可读，select/poll就会返回，通知用户去读取数据
        
    边沿(缘)触发:
		epoll提供两种方式供用户选择，默认使用水平触发
		边沿触发只在第一次收到数据时通知用户，如果用户没有一次性把数据读完，下一次epoll_wait时，不会通知用户
		如果需要设置为边沿触发，需要在设置的时候按位或上一个EPOLLET即可
		如：
		struct epoll_event event;
		event.event = EPOLLIN | EPOLLET;
```

作业(扩展)：
		Linux中IO除了多路复用的模式(模型)， 还有哪些其他的模式(模型，使用方法)



### 六、UDP

UDP成为用户数据报(包)协议(用户数据协议)，它是一种无连接的，不可靠的，消息有最大长度限制的传输层协议。   ===>  传输速度快



UDP通信模型：

发送端(客户端)：
	1、创建一个通信节点socket（创建用户数据报套接字）
	2、发送数据报(包)sendto
	3、关闭套接字(close)



接收端(服务端):
	1、创建一个通信节点socket（创建用户数据报套接字）
	2、绑定一个地址到套接字bind
	3、接收数据报(包) recvfrom
	4、关闭套接字 close

![UDP编程步骤](%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/UDP%E7%BC%96%E7%A8%8B%E6%AD%A5%E9%AA%A4.png) 

#### 7.1 接收发送数据

#### recvfrom,

#### sendto

```c
NAME
       send, sendto, sendmsg - send a message on a socket

SYNOPSIS
       #include <sys/types.h>
       #include <sys/socket.h>
	功能: 用于发送数据
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);
	sockfd: 套接字描述符
    buf: 指向需要发送的数据
	len: 待发送的数据的长度，单位是字节
	flag: 发送标志  一般置0  使用默认阻塞的方式发送
    dest_addr: 目标地址信息
	addrlen： 目标地址信息的长度

返回值:
	成功返回实际发送的字节数
	失败返回-1，同时errno被设置
        
-------------------------------------------------------------------
       #include <sys/types.h>
       #include <sys/socket.h>

ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);
	sockfd: 套接字描述符
	buf: 把接收到的数据存储到buf指向的空间
	len: 接收缓冲区的大小
	flag: 接收标志  一般置0，使用默认阻塞的方式接收  如果不需要阻塞，则可以使用MSG_DONTWAIT
	src_addr: 数据的来源地址   如果不需要对方的地址信息，则可以填NULL
	addrlen: 用于存储数据来源地址信息的结构体的大小，必须初始化，如果不需要对方的地址信息，则填NULL

返回值:
	成功返回实际接收到的字节数
	失败返回-1，同时errno被设置
```



#### 7.2 广播

广播是UDP协议的典型使用之一，通过广播，可以把消息发送给同一网络中的所有主机



要使用广播通信需要：


1、使用广播地址
	  受限广播地址  255.255.255.255
	  子网定向广播地址:  IP地址中主机号全为1的IP地址:  172.100.1.255



2、设置套接字选项，激活广播功能
	  设置允许发送广播数据报
![image-20240807100222667](%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/image-20240807100222667.png) 

```c
层次: SOL_SOCKET
选项名: SO_BROADCAST
数据类型: int  设置为1表示激活广播功能呢
    
//激活广播功能
int value = 1;
int r = setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, (void*)&value, sizeof(value));
```


实现 步骤:



发送端(客户端)：
	1、创建一个通信节点socket（创建用户数据报套接字）

​	2、激活广播功能 setsockopt

​	3、向广播地址(172.100.1.255)发送数据报(包)sendto
​	4、关闭套接字(close)



接收端(服务端):
	1、创建一个通信节点socket（创建用户数据报套接字）
	2、绑定广播地址(172.100.1.255)到套接字bind
	3、接收数据报(包) recvfrom
	4、关闭套接字 close



###### 代码

```c
UDP广播发送方
发送方需要将目的地址设置为特定的广播地址（如IPv4中的255.255.255.255，但这可能因网络配置而异，如子网广播地址），并将套接字选项SO_BROADCAST设置为允许广播。
    
#include <stdio.h>  
#include <stdlib.h>  
#include <string.h>  
#include <unistd.h>  
#include <arpa/inet.h>  
#include <sys/socket.h>  
  
int main() {  
    int sockfd;  
    struct sockaddr_in broadcastAddr;  
    char broadcastIP[] = "255.255.255.255";  
    unsigned short broadcastPort = 8888;  
    char *hello = "Hello, UDP Broadcast!";  
  
    // 创建UDP套接字  
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {  
        perror("socket creation failed");  
        exit(EXIT_FAILURE);  
    }  
  
    // 允许广播  
    int yes = 1;  
    if (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &yes, sizeof(int)) < 0) {  
        perror("setsockopt (SO_BROADCAST) failed");  
        exit(EXIT_FAILURE);  
    }  
  
    memset(&broadcastAddr, 0, sizeof(broadcastAddr));  
    broadcastAddr.sin_family = AF_INET;  
    broadcastAddr.sin_addr.s_addr = inet_addr(broadcastIP);  
    broadcastAddr.sin_port = htons(broadcastPort);  
  
    // 发送广播消息  
    if (sendto(sockfd, (const char *)hello, strlen(hello), 0,  
               (const struct sockaddr *)&broadcastAddr, sizeof(broadcastAddr)) < 0) {  
        perror("sendto failed");  
        exit(EXIT_FAILURE);  
    }  
  
    printf("Hello message sent\n");  
  
    close(sockfd);  
    return 0;  
}


UDP广播接收方
接收方需要将套接字绑定到一个端口上，这个端口是发送方发送消息时指定的端口。与发送方不同，接收方不需要设置SO_BROADCAST选项。


#include <stdio.h>  
#include <stdlib.h>  
#include <string.h>  
#include <unistd.h>  
#include <arpa/inet.h>  
#include <sys/socket.h>  
  
#define BUFLEN 512  
  
int main() {  
    int sockfd;  
    struct sockaddr_in si_me, si_other;  
    socklen_t slen = sizeof(si_other);  
    char buf[BUFLEN];  
  
    // 创建UDP套接字  
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {  
        perror("socket creation failed");  
        exit(EXIT_FAILURE);  
    }  
  
    memset((char *) &si_me, 0, sizeof(si_me));  
    si_me.sin_family = AF_INET;  
    si_me.sin_port = htons(8888);  
    si_me.sin_addr.s_addr = htonl(INADDR_ANY);  
  
    // 绑定套接字  
    if (bind(sockfd, (struct sockaddr *)&si_me, sizeof(si_me)) == -1) {  
        perror("bind failed");  
        exit(EXIT_FAILURE);  
    }  
  
    // 接收数据  
    while (1) {  
        if (recvfrom(sockfd, (char *)buf, BUFLEN, 0,  
                     (struct sockaddr *) &si_other, &slen) == -1) {  
            perror("recvfrom");  
            exit(EXIT_FAILURE);  
        }  
  
        printf("Received packet from %s:%d\nData: %s\n",  
               inet_ntoa(si_other.sin_addr), ntohs(si_other.sin_port), buf);  
    }  
  
    close(sockfd);  
    return 0;  
}
```



#### 7.3 组(多)播

组播也是UDP的一种应用，通过组播，可以把消息发送给同一多播组中的所有主机



1、使用组播地址

![image-20240807110400997](%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/image-20240807110400997.png) 



使用D类地址即可，如:  224.3.4.5

2、设置套接字选项，加入某个多播组
加入多播组
![image-20240807110515909](%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/image-20240807110515909.png) 


```C
层次: IPPROTO_IP
套接字选项: IP_ADD_MEMBERSHIP
数据类型: ip_mreq(结构体)
    
	struct ip_mreqn {
          struct in_addr imr_multiaddr; /* 多播组的IP地址 */
          struct in_addr imr_address;   /* 要加入多播组的那台主机的IP地址 */
           int    imr_ifindex;          /* 接口索引，一般不需要 */
      };
```

3、如果需要接收来自某个多播组的信息，必须加入多播组
      如果仅仅是发送信息，只要给特定的多播组发送信息就行了





实现步骤:



发送端(客户端)：
	1、创建一个通信节点socket（创建用户数据报套接字）

​	3、向多播组地址发送数据报(包)sendto
​	4、关闭套接字(close)



接收端(服务端):
	1、创建一个通信节点socket（创建用户数据报套接字）
	2、加入到多播组

​	2、绑定多播组地址到套接字bind
​	3、接收数据报(包) recvfrom
​	4、关闭套接字 close



### 八、UNIX协议域

UNIX协议域也叫做本地协议域，是用于同一设备上面不同进程之间的一种通信方式，所用API就是在不同主机上执行客户端(Client)/服务端(server)通信(C/S通信)所用的套接字API




unix协议域提供两类套接字:  字节流套接字(类似TCP)和数据报套接字(类似UDP)



本地使用unix域套接字优点:

1、UNIX协议域的速度比  Internet domain速度快

2、可以使用文件权限来控制UNIX协议域的访问，这样只有运行于指定用户或者用户组下的应用程序才能连接到一个监听套接字socket或向一个数据报socket发送一个数据

3、UNIX协议域套接字可以在同一主机上不同进程之间传递文件描述符
	  UNIX协议域与Internet最明显的一个差别就是协议地址的表示

​	  IPV4协议地址由一个32位的地址和一个16位的端口号组成，IPV6协议地址则由一个128位地址和一个16位端口号组成
​	  UNIX协议域用于标识客户端和服务端的协议地址是: **普通文件系统中的路径名**



```c
通过man UNIX查看UNIX协议域的地址配置结构体

struct sockaddr_un {
    sa_family_t sun_family;               /* AF_UNIX */
    char        sun_path[108];            /* 路径名 */
};

说明:
	在调用bind函数绑定unix协议域时，如果文件系统中已经存在该路径名，bind会失败
	我们每次绑定之前，需要先试着删除这个路径名 (unlink), 以防止它已经存在了
```

### 九、抓包工具

#### 9.1 tcpdump

Linux终端可以使用tcpdump来抓取网络传输中的数据包



如:
		sudo  tcpdump  -i  lo  port  10010
		抓取lo网卡上的端口号为10010上经过的数据包（只能查看数据包的大致信息）



#### 9.2 wireshark

Wireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是截取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。



在过去，网络封包分析软件是非常昂贵的，或是专门属于盈利用的软件。Ethereal的出现改变了这一切。在GNUGPL通用许可证的保障范围底下，使用者可以以免费的途径取得软件与其源代码，并拥有针对其源代码修改及客制化的权利。Ethereal是全世界最广泛的网络封包分析软件之一。


Wireshark的使用参考《WireShark的使用》

清零

​	&0     



保留

​	&1   ，|0	



置一

​	|1



取反

​	^1













































































































































